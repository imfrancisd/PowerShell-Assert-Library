<?xml version="1.0" encoding="utf-8"?>
<helpItems xmlns="http://msh" schema="maml">
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-All</command:name>
      <maml:description>
        <maml:para>Assert that a predicate is true for all items in a collection.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>All</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the predicate is not true for at least one item in the collection

Note:
The assertion will always pass if the collection is empty.

*See the -Collection and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-All</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Collection</maml:name>
          <maml:description>
            <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Collection</maml:name>
        <maml:description>
          <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-All $numbers {param($n) $n -is [system.int32]}
Assert-All $numbers {param($n) $n % 2 -eq 0}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-All @(1, 2, 3, 4, 5) {param($n) $n -gt 0}</dev:code>
        <dev:remarks>
          <maml:para>Assert that all items in the array are greater than 0.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-All @() {param($n) $n -gt 0}</dev:code>
        <dev:remarks>
          <maml:para>Assert that all items in the array are greater than 0.

Note:
This assertion will always pass because the array is empty.
This is known as vacuous truth.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-All @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -gt 5} -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Assert that all entries in the hashtable have a value greater than 5.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-All @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -gt 5} -Debug</dev:code>
        <dev:remarks>
          <maml:para>Assert that all entries in the hashtable have a value greater than 5.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-Exists</command:name>
      <maml:description>
        <maml:para>Assert that a predicate is true for some of the items in a collection.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>Exists</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the predicate is not true for any item in the collection

Note:
The assertion will always fail if the collection is empty.

*See the -Collection and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-Exists</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Collection</maml:name>
          <maml:description>
            <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Collection</maml:name>
        <maml:description>
          <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-Exists $numbers {param($n) $n -is [system.int32]}
Assert-Exists $numbers {param($n) $n % 2 -eq 0}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Exists @(1, 2, 3, 4, 5) {param($n) $n -gt 3}</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one item in the array is greater than 3.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Exists @() {param($n) $n -gt 3}</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one item in the array is greater than 3.

Note:
This assertion will always fail because the array is empty.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Exists @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -gt 25} -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one entry in the hashtable has a value greater than 25.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Exists @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -gt 25} -Debug</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one entry in the hashtable has a value greater than 25.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-False</command:name>
      <maml:description>
        <maml:para>Assert that a value is the Boolean value $false.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>False</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the value being asserted is $null
    *the value being asserted is not of type System.Boolean
    *the value being asserted is not $false</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-False</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to assert.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to assert.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-False ($null -eq $a)
Assert-False ($null -eq $b)
Assert-False ($a -eq $b)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-False ($a -eq $b)</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) does not evaluate to $false.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-False ($a -eq $b) -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) does not evaluate to $false.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-False ($a -eq $b) -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) does not evaluate to $false.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-NotExists</command:name>
      <maml:description>
        <maml:para>Assert that a predicate is not true for any item in a collection.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>NotExists</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the predicate is true for some of the items in the collection

Note:
The assertion will always pass if the collection is empty.

*See the -Collection and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-NotExists</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Collection</maml:name>
          <maml:description>
            <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Collection</maml:name>
        <maml:description>
          <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-NotExists $numbers {param($n) $n -isnot [system.int32]}
Assert-NotExists $numbers {param($n) $n % 2 -ne 0}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotExists @(1, 2, 3, 4, 5) {param($n) $n -gt 10}</dev:code>
        <dev:remarks>
          <maml:para>Assert that no item in the array is greater than 10.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotExists @() {param($n) $n -gt 10}</dev:code>
        <dev:remarks>
          <maml:para>Assert that no item in the array is greater than 10.

Note:
This assertion will always pass because the array is empty.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotExists @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -lt 0} -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Assert that no entry in the hashtable has a value less than 0.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotExists @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -lt 0} -Debug</dev:code>
        <dev:remarks>
          <maml:para>Assert that no entry in the hashtable has a value less than 0.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-NotFalse</command:name>
      <maml:description>
        <maml:para>Assert that a value is not the Boolean value $false.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>NotFalse</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the value being asserted is the System.Boolean value $false</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-NotFalse</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to assert.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to assert.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-NotFalse ($null -eq $a)
Assert-NotFalse ($null -eq $b)
Assert-NotFalse ($a -eq $b)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotFalse ($a -eq $b)</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) evaluates to $false.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotFalse ($a -eq $b) -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) evaluates to $false.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotFalse ($a -eq $b) -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) evaluates to $false.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-NotNull</command:name>
      <maml:description>
        <maml:para>Assert that a value is not $null.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>NotNull</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the value being asserted is $null</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-NotNull</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to assert.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to assert.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-NotNull $a
Assert-NotNull $b
Assert-NotNull $c</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotNull $a</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if $a evaluates to $null.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotNull $a -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if $a evaluates to $null.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotNull $a -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if $a evaluates to $null.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-NotTrue</command:name>
      <maml:description>
        <maml:para>Assert that a value is not the Boolean value $true.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>NotTrue</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the value being asserted is the System.Boolean value $true</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-NotTrue</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to assert.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to assert.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-NotTrue ($a -is [System.Int32])
Assert-NotTrue ($b -is [System.Int32])
Assert-NotTrue ($a -eq $b)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotTrue ($a -eq $b)</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) evaluates to $true.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotTrue ($a -eq $b) -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) evaluates to $true.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-NotTrue ($a -eq $b) -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) evaluates to $true.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-Null</command:name>
      <maml:description>
        <maml:para>Assert that a value is $null.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>Null</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the value being asserted is not $null</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-Null</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to assert.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to assert.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-Null $a
Assert-Null $b
Assert-Null $c</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Null $a</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if $a does not evaluate to $null.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Null $a -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if $a does not evaluate to $null.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-Null $a -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if $a does not evaluate to $null.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineAll</command:name>
      <maml:description>
        <maml:para>Assert that a predicate is true for all objects in a pipeline.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineAll</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the predicate is not true for at least one object in the pipeline

Note:
The assertion will always pass if the pipeline is empty.

*See the -InputObject and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineAll</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object that is used to test the predicate.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked for each object in the pipeline.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object that is used to test the predicate.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked for each object in the pipeline.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Object

If the assertion passes, this function outputs the objects from the pipeline input.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

$numbers = myNumberGenerator |
    Assert-PipelineAll {param($n) $n -is [system.int32]} |
    Assert-PipelineAll {param($n) $n % 2 -eq 0} |
    Assert-PipelineAll {param($n) $n -gt 0}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@(1, 2, 3, 4, 5) | Assert-PipelineAll {param($n) $n -gt 0}</dev:code>
        <dev:remarks>
          <maml:para>Assert that all items in the array are greater than 0, and outputs each item one at a time.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@() | Assert-PipelineAll {param($n) $n -gt 0}</dev:code>
        <dev:remarks>
          <maml:para>Assert that all items in the array are greater than 0, and outputs each item one at a time.

Note:
This assertion will always pass because the array is empty.
This is known as vacuous truth.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@{a0 = 10; a1 = 20; a2 = 30}.GetEnumerator() | Assert-PipelineAll {param($entry) $entry.Value -gt 5} -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Assert that all entries in the hashtable have a value greater than 5, and outputs each entry one at a time.
The -Verbose switch will output the result of the assertion to the Verbose stream.

Note:
The GetEnumerator() method must be used in order to pipe the entries of a hashtable into a function.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@{a0 = 10; a1 = 20; a2 = 30}.GetEnumerator() | Assert-PipelineAll {param($entry) $entry.Value -gt 5} -Debug</dev:code>
        <dev:remarks>
          <maml:para>Assert that all entries in the hashtable have a value greater than 5, and outputs each entry one at a time.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.

Note:
The GetEnumerator() method must be used in order to pipe the entries of a hashtable into a function.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineAny</command:name>
      <maml:description>
        <maml:para>Assert that the pipeline contains one or more objects.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineAny</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function is useful for asserting that a function returns one or more objects.

This function throws an error if any of the following conditions are met:
    *the pipeline contains less than one object</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineAny</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="1" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="1" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Object

If the assertion passes, this function outputs the objects from the pipeline input.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

$a = myFunc1 | Assert-PipelineAny
$b = myFunc2 | Assert-PipelineAny
$c = myFunc3 | Assert-PipelineAny</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$letter = 'a', 'b', 'c' | Get-Random | Assert-PipelineAny</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random does not return any objects.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$letter = 'a', 'b', 'c' | Get-Random | Assert-PipelineAny -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random does not return any objects.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$letter = 'a', 'b', 'c' | Get-Random | Assert-PipelineAny -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random does not return any objects.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineCount</command:name>
      <maml:description>
        <maml:para>Assert the number of objects in the pipeline.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineCount</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function is useful for asserting that a function outputs the correct number of objects.

See the -Equals, -Minimum, and -Maximum parameters for more details.

Note:
This function will output all pipeline objects it receives until an error is thrown, or until there are no more objects left in the pipeline.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineCount</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>This function will throw an error if the number of objects in the pipeline is not equal to the number specified by this parameter.

Note:
A negative number will always cause this assertion to fail.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int64</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Assert-PipelineCount</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Minimum</maml:name>
          <maml:description>
            <maml:para>This function will throw an error if the number of objects in the pipeline is less than the number specified by this parameter.

Note:
A negative number will always cause this assertion to pass.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int64</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Assert-PipelineCount</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Maximum</maml:name>
          <maml:description>
            <maml:para>This function will throw an error if the number of objects in the pipeline is more than the number specified by this parameter.

Note:
A negative number will always cause this assertion to fail.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int64</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>This function will throw an error if the number of objects in the pipeline is not equal to the number specified by this parameter.

Note:
A negative number will always cause this assertion to fail.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Int64</command:parameterValue>
        <dev:type>
          <maml:name>Int64</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>0</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Minimum</maml:name>
        <maml:description>
          <maml:para>This function will throw an error if the number of objects in the pipeline is less than the number specified by this parameter.

Note:
A negative number will always cause this assertion to pass.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Int64</command:parameterValue>
        <dev:type>
          <maml:name>Int64</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>0</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Maximum</maml:name>
        <maml:description>
          <maml:para>This function will throw an error if the number of objects in the pipeline is more than the number specified by this parameter.

Note:
A negative number will always cause this assertion to fail.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Int64</command:parameterValue>
        <dev:type>
          <maml:name>Int64</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>0</dev:defaultValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Object

If the assertion passes, this function outputs the objects from the pipeline input.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

$a = myFunc1 | Assert-PipelineCount 10
$b = myFunc2 | Assert-PipelineCount -Minimum 1
$c = myFunc3 | Assert-PipelineCount -Maximum 2
$d = myFunc4 | Assert-PipelineCount -Minimum 3 | Assert-PipelineCount -Maximum 14</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$nums = 1..100 | Get-Random -Count 10 | Assert-PipelineCount 10</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random -Count 10 does not return exactly ten objects.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$nums = 1..100 | Get-Random -Count 10 | Assert-PipelineCount -Maximum 10</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random -Count 10 returns more than ten objects.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$nums = 1..100 | Get-Random -Count 10 | Assert-PipelineCount -Minimum 10</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random -Count 10 returns less than ten objects.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$nums = 1..100 | Get-Random -Count 10 | Assert-PipelineCount 10 -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random -Count 10 does not return exactly ten objects.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 5 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$nums = 1..100 | Get-Random -Count 10 | Assert-PipelineCount 10 -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random -Count 10 does not return exactly ten objects.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 6 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$a = Get-ChildItem 'a*' | Assert-PipelineCount -Minimum 5 | Assert-PipelineCount -Maximum 10</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-ChildItem 'a*' either returns less than five objects, or returns more than 10 objects.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineEmpty</command:name>
      <maml:description>
        <maml:para>Assert that the pipeline does not contain any objects.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineEmpty</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function is useful for asserting that a function does not output any objects.

This function throws an error if any of the following conditions are met:
    *the pipeline contains an object</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineEmpty</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="1" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="1" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

myFunc1 | Assert-PipelineEmpty
myFunc2 | Assert-PipelineEmpty
myFunc3 | Assert-PipelineEmpty</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Get-ChildItem 'aFileThatDoesNotExist*' | Assert-PipelineEmpty</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-ChildItem 'aFileThatDoesNotExist*' returns an object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Get-ChildItem 'aFileThatDoesNotExist*' | Assert-PipelineEmpty -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-ChildItem 'aFileThatDoesNotExist*' returns an object.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Get-ChildItem 'aFileThatDoesNotExist*' | Assert-PipelineEmpty -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-ChildItem 'aFileThatDoesNotExist*' returns an object.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineExists</command:name>
      <maml:description>
        <maml:para>Assert that a predicate is true for some objects in the pipeline.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineExists</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the predicate is not true for any object in the pipeline

Note:
The assertion will always fail if the pipeline is empty.

*See the -InputObject and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineExists</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object that is used to test the predicate.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked for each object in the pipeline.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object that is used to test the predicate.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked for each object in the pipeline.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Object

If the assertion passes, this function outputs the objects from the pipeline input.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

$numbers = myNumberGenerator |
    Assert-PipelineExists {param($n) $n -is [system.int32]} |
    Assert-PipelineExists {param($n) $n % 2 -eq 0} |
    Assert-PipelineExists {param($n) $n -gt 0}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@(1, 2, 3, 4, 5) | Assert-PipelineExists {param($n) $n -gt 3}</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one item in the array is greater than 3, and outputs each item one at a time.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@() | Assert-PipelineExists {param($n) $n -gt 3}</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one item in the array is greater than 3, and outputs each item one at a time.

Note:
This assertion will always fail because the array is empty.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@{a0 = 10; a1 = 20; a2 = 30}.GetEnumerator() | Assert-PipelineExists {param($entry) $entry.Value -gt 25} -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one entry in the hashtable has a value greater than 25, and outputs each entry one at a time.
The -Verbose switch will output the result of the assertion to the Verbose stream.

Note:
The GetEnumerator() method must be used in order to pipe the entries of a hashtable into a function.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@{a0 = 10; a1 = 20; a2 = 30}.GetEnumerator() | Assert-PipelineExists {param($entry) $entry.Value -gt 25} -Debug</dev:code>
        <dev:remarks>
          <maml:para>Assert that at least one entry in the hashtable has a value greater than 25, and outputs each entry one at a time.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.

Note:
The GetEnumerator() method must be used in order to pipe the entries of a hashtable into a function.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineNotExists</command:name>
      <maml:description>
        <maml:para>Assert that a predicate is not true for any object in the pipeline.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineNotExists</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the predicate is true for some of the objects in the pipeline

Note:
The assertion will always pass if the pipeline is empty.

*See the -InputObject and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineNotExists</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object that is used to test the predicate.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked for each object in the pipeline.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="named" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object that is used to test the predicate.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked for each object in the pipeline.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Object

If the assertion passes, this function outputs the objects from the pipeline input.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

$numbers = myNumberGenerator |
    Assert-PipelineNotExists {param($n) $n -isnot [system.int32]} |
    Assert-PipelineNotExists {param($n) $n % 2 -ne 0} |
    Assert-PipelineNotExists {param($n) $n -gt 0}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@(1, 2, 3, 4, 5) | Assert-PipelineNotExists {param($n) $n -gt 10}</dev:code>
        <dev:remarks>
          <maml:para>Assert that no item in the array is greater than 10, and outputs each item one at a time.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@() | Assert-PipelineNotExists {param($n) $n -gt 10}</dev:code>
        <dev:remarks>
          <maml:para>Assert that no item in the array is greater than 10, and outputs each item one at a time.

Note:
This assertion will always pass because the array is empty.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@{a0 = 10; a1 = 20; a2 = 30}.GetEnumerator() | Assert-PipelineNotExists {param($entry) $entry.Value -lt 0} -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Assert that no entry in the hashtable has a value less than 0, and outputs each entry one at a time.
The -Verbose switch will output the result of the assertion to the Verbose stream.

Note:
The GetEnumerator() method must be used in order to pipe the entries of a hashtable into a function.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>@{a0 = 10; a1 = 20; a2 = 30}.GetEnumerator() | Assert-PipelineNotExists {param($entry) $entry.Value -lt 0} -Debug</dev:code>
        <dev:remarks>
          <maml:para>Assert that no entry in the hashtable has a value less than 0, and outputs each entry one at a time.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.

Note:
The GetEnumerator() method must be used in order to pipe the entries of a hashtable into a function.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-PipelineSingle</command:name>
      <maml:description>
        <maml:para>Assert that the pipeline only contains one object.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>PipelineSingle</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function is useful for asserting that a function only returns a single object.

This function throws an error if any of the following conditions are met:
    *the pipeline contains less than one object
    *the pipeline contains more than one object</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-PipelineSingle</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="1" aliases="">
          <maml:name>InputObject</maml:name>
          <maml:description>
            <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="true (ByValue)" position="1" aliases="">
        <maml:name>InputObject</maml:name>
        <maml:description>
          <maml:para>The object from the pipeline.

Note:
The argument for this parameter must come from the pipeline.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>System.Object

This function accepts any kind of object from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Object

If the assertion passes, this function outputs the objects from the pipeline input.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

$a = myFunc1 | Assert-PipelineSingle
$b = myFunc2 | Assert-PipelineSingle
$c = myFunc3 | Assert-PipelineSingle</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$letter = 'a', 'b', 'c' | Get-Random | Assert-PipelineSingle</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random does not return a single object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$letter = 'a', 'b', 'c' | Get-Random | Assert-PipelineSingle -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random does not return a single object.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>$letter = 'a', 'b', 'c' | Get-Random | Assert-PipelineSingle -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if Get-Random does not return a single object.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Assert-True</command:name>
      <maml:description>
        <maml:para>Assert that a value is the Boolean value $true.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Assert</command:verb>
      <command:noun>True</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function throws an error if any of the following conditions are met:
    *the value being asserted is $null
    *the value being asserted is not of type System.Boolean
    *the value being asserted is not $true</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Assert-True</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to assert.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to assert.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>None</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#display passing assertions
$VerbosePreference = [System.Management.Automation.ActionPreference]::Continue

#display debug prompt on failing assertions
$DebugPreference = [System.Management.Automation.ActionPreference]::Inquire

Assert-True ($a -is [System.Int32])
Assert-True ($b -is [System.Int32])
Assert-True ($a -eq $b)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-True ($a -eq $b)</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) does not evaluate to $true.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-True ($a -eq $b) -Verbose</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) does not evaluate to $true.
The -Verbose switch will output the result of the assertion to the Verbose stream.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Assert-True ($a -eq $b) -Debug</dev:code>
        <dev:remarks>
          <maml:para>Throws an error if the expression ($a -eq $b) does not evaluate to $true.
The -Debug switch gives you a chance to investigate a failing assertion before an error is thrown.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Assert-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineEmpty</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAny</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineSingle</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Group-ListItem</command:name>
      <maml:description>
        <maml:para>Generates groups of items (such as combinations, permutations, and Cartesian products) from lists that make common testing tasks easy and simple.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Group</command:verb>
      <command:noun>ListItem</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>Generates groups of items from lists that can be used to create test input data, or to analyze test output data.

Here are the names of the list processing functions:

    Pair, Window,
    RotateLeft, RotateRight,
    Combine, Permute,
    CartesianProduct, CoveringArray, and Zip.

With these functions, many tasks that would require nested loops can be simplified to a single loop or a single pipeline. Here is an example of testing multiple scripts using different PowerShell configurations.

    $versions     = @(2, 4)
    $apStates     = @('-sta', '-mta')
    $execPolicies = @('remotesigned')
    $fileNames    = @('.\script1.ps1', '.\script2.ps1', '.\script3.ps1')

    Group-ListItem -CartesianProduct $versions, $apStates, $execPolicies, $fileNames | % {
        $ver, $aps, $exp, $file = $_.Items
        if (($ver -le 2) -and ($aps -eq '-mta')) {$aps = ''}    #PS2 has no -mta switch

        powershell -version $ver $aps -noprofile -noninteractive -executionpolicy $exp -file $file
    }

This kind of task typically requires nested loops (one loop for each parameter), but this example uses Group-ListItem -CartesianProduct to generate the parameter values for powershell.exe.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Pair</maml:name>
          <maml:description>
            <maml:para>Groups adjacent items inside a list.
Each group has two items.

Note:
This function does not return any groups if:
    *the length of the list is less than 2.

The input list is never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Window</maml:name>
          <maml:description>
            <maml:para>Groups adjacent items inside a list.
The number of items in each group is specified with the -Size parameter.
If the -Size parameter is not specified, the number of items in each group is the same as the length of the list.

Note:
This function does not return any groups if:
    *the value of the -Size parameter is less than 0
    *the value of the -Size parameter is greater than the length of the list.

This function will return 1 group with 0 items if:
    *the value of the -Size parameter is 0.

The input list is never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Size</maml:name>
          <maml:description>
            <maml:para>The number of items per group for combinations, permutations, and windows.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int32</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>RotateLeft</maml:name>
          <maml:description>
            <maml:para>Groups items in a list by rotating them to the left until they return to their original position.

    Example:
    Group-ListItem -RotateLeft @(1, 2, 3)

    Items
    -----
    {1, 2, 3}
    {2, 3, 1}
    {3, 1, 2}

    Notice how the last item (3) moves to the left.

Note:
This function will return 1 group with 0 items if:
    *the length of the list is 0.

The input list is never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>RotateRight</maml:name>
          <maml:description>
            <maml:para>Groups items in a list by rotating them to the right until they return to their original position.

    Example:
    Group-ListItem -RotateRight @(1, 2, 3)

    Items
    -----
    {1, 2, 3}
    {3, 1, 2}
    {2, 3, 1}

    Notice how the first item (1) moves to the right.

Note:
This function will return 1 group with 0 items if:
    *the length of the list is 0.

The input list is never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Combine</maml:name>
          <maml:description>
            <maml:para>Groups items inside a list into combinations.
The number of items in each group is specified with the -Size parameter.
If the -Size parameter is not specified, the number of items in each group is the same as the length of the list.

Note:
This function does not return any groups if:
    *the value of the -Size parameter is less than 0
    *the value of the -Size parameter is greater than the length of the list.

This function will return 1 group with 0 items if:
    *the value of the -Size parameter is 0.

The input list is never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Size</maml:name>
          <maml:description>
            <maml:para>The number of items per group for combinations, permutations, and windows.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int32</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Permute</maml:name>
          <maml:description>
            <maml:para>Groups items inside a list into permutations.
The number of items in each group is specified with the -Size parameter.
If the -Size parameter is not specified, the number of items in each group is the same as the length of the list.

Note:
This function does not return any groups if:
    *the value of the -Size parameter is less than 0
    *the value of the -Size parameter is greater than the length of the list.

This function will return 1 group with 0 items if:
    *the value of the -Size parameter is 0.

The input list is never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Size</maml:name>
          <maml:description>
            <maml:para>The number of items per group for combinations, permutations, and windows.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int32</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CartesianProduct</maml:name>
          <maml:description>
            <maml:para>Groups items from 0 or more lists into cartesian products.
Each group has the same number of items as the number of lists specified.

Note:
This function does not return any groups if:
    *no lists are specified
    *any of the specified lists are empty.

The lists do not need to have the same number of items.

The lists (and the list that contains them) are never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CoveringArray</maml:name>
          <maml:description>
            <maml:para>Groups items from 0 or more lists into a filtered output of cartesian product for t-way testing.
Each group has the same number of items as the number of lists specified.

See the -Strength parameter for more details.

Note:
This function does not return any groups if:
    *no lists are specified
    *any of the specified lists are empty
    *the value of the -Strength parameter is negative or 0.

This function will return the cartesian product if:
    *the -Strength parameter is not specified
    *the value of the -Strength parameter is greater than or equal to the number of lists.

The lists do not need to have the same number of items.

The lists (and the list that contains them) are never modified by this function.


Implementation Notes:
    *does not always create the smallest covering array possible
    *repeatable covering array output (no randomization)
    *streaming covering array output (no unnecessary waiting)


=======================================================================
See nist.gov for more details about covering arrays:
    Practical Combinatorial Testing
    by D. Richard Kuhn, Raghu N. Kacker, and Yu Lei
    http://csrc.nist.gov/groups/SNS/acts/documents/SP800-142-101006.pdf

    NIST Covering Array Tables - What is a covering array?
    http://math.nist.gov/coveringarrays/coveringarray.html
=======================================================================</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Strength</maml:name>
          <maml:description>
            <maml:para>The strength of the covering array.

A covering array of strength n is a filtered form of Cartesian product where all n-tuple of values from any n lists appears in at least 1 row of the output.

Example:

    $aList = @('a1','a2')
    $bList = @('b1','b2')
    $cList = @('c1','c2')
    $dList = @('d1','d2','d3')

    group-listItem -coveringArray $aList, $bList, $cList, $dList -strength 2

Outputs the covering array:

    Items
    -----
    {a1, b1, c1, d1}
    {a1, b1, c1, d2}
    {a1, b1, c1, d3}
    {a1, b1, c2, d1}
    {a1, b1, c2, d2}
    {a1, b1, c2, d3}
    {a1, b2, c1, d1}
    {a1, b2, c1, d2}
    {a1, b2, c1, d3}
    {a1, b2, c2, d1}
    {a2, b1, c1, d1}
    {a2, b1, c1, d2}
    {a2, b1, c1, d3}
    {a2, b1, c2, d1}
    {a2, b2, c1, d1}

The covering array above has a strength of 2 because if you take any 2 lists from the input, all the ways that the values from those 2 lists can be grouped appears in one or more rows in the output.
    $aList, $bList: (a1, b1) (a1, b2) (a2, b1) (a2, b2)
    $aList, $cList: (a1, c1) (a1, c2) (a2, c1) (a2, c2)
    $aList, $dList: (a1, d1) (a1, d2) (a1, d3) (a2, d1) (a2, d2) (a2, d3)
    $bList, $cList: (b1, c1) (b1, c2) (b2, c1) (b2, c2)
    $bList, $dList: (b1, d1) (b1, d2) (b1, d3) (b2, d1) (b2, d2) (b2, d3)
    $cList, $dList: (c1, d1) (c1, d2) (c1, d3) (c2, d1) (c2, d2) (c2, d3)

The covering array above DOES NOT have a strength of 3 because if you take any 3 lists from the input, the output DOES NOT contain all the ways that the values from those 3 lists can be grouped.
    $aList, $bList, $cList: (a2, b2, c2) missing
    $aList, $bList, $dList: (a2, b2, d2) (a2, b2, d3) missing
    $aList, $cList, $dList: (a2, c2, d2) (a2, c2, d3) missing
    $bList, $cList, $dList: (b2, c2, d2) (b2, c2, d3) missing

In general, covering arrays with a high strength have more rows than covering arrays with a low strength, and the Cartesian product is a covering array with the highest strength possible.


=======================================================================
See nist.gov for more details about covering arrays:
    Practical Combinatorial Testing
    by D. Richard Kuhn, Raghu N. Kacker, and Yu Lei
    http://csrc.nist.gov/groups/SNS/acts/documents/SP800-142-101006.pdf

    NIST Covering Array Tables - What is a covering array?
    http://math.nist.gov/coveringarrays/coveringarray.html
=======================================================================</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Int32</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Group-ListItem</maml:name>
        <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Zip</maml:name>
          <maml:description>
            <maml:para>Groups items from 0 or more lists that have the same index.
Each group has the same number of items as the number of lists specified.

Note:
This function does not return any groups if:
    *no lists are specified
    *any of the specified lists are empty.

If the lists do not have the same number of items, the number of groups in the output is equal to the number of items in the list with the fewest items.

The lists (and the list that contains them) are never modified by this function.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">IList[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Pair</maml:name>
        <maml:description>
          <maml:para>Groups adjacent items inside a list.
Each group has two items.

Note:
This function does not return any groups if:
    *the length of the list is less than 2.

The input list is never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        <dev:type>
          <maml:name>IList</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Window</maml:name>
        <maml:description>
          <maml:para>Groups adjacent items inside a list.
The number of items in each group is specified with the -Size parameter.
If the -Size parameter is not specified, the number of items in each group is the same as the length of the list.

Note:
This function does not return any groups if:
    *the value of the -Size parameter is less than 0
    *the value of the -Size parameter is greater than the length of the list.

This function will return 1 group with 0 items if:
    *the value of the -Size parameter is 0.

The input list is never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        <dev:type>
          <maml:name>IList</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>RotateLeft</maml:name>
        <maml:description>
          <maml:para>Groups items in a list by rotating them to the left until they return to their original position.

    Example:
    Group-ListItem -RotateLeft @(1, 2, 3)

    Items
    -----
    {1, 2, 3}
    {2, 3, 1}
    {3, 1, 2}

    Notice how the last item (3) moves to the left.

Note:
This function will return 1 group with 0 items if:
    *the length of the list is 0.

The input list is never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        <dev:type>
          <maml:name>IList</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>RotateRight</maml:name>
        <maml:description>
          <maml:para>Groups items in a list by rotating them to the right until they return to their original position.

    Example:
    Group-ListItem -RotateRight @(1, 2, 3)

    Items
    -----
    {1, 2, 3}
    {3, 1, 2}
    {2, 3, 1}

    Notice how the first item (1) moves to the right.

Note:
This function will return 1 group with 0 items if:
    *the length of the list is 0.

The input list is never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        <dev:type>
          <maml:name>IList</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Combine</maml:name>
        <maml:description>
          <maml:para>Groups items inside a list into combinations.
The number of items in each group is specified with the -Size parameter.
If the -Size parameter is not specified, the number of items in each group is the same as the length of the list.

Note:
This function does not return any groups if:
    *the value of the -Size parameter is less than 0
    *the value of the -Size parameter is greater than the length of the list.

This function will return 1 group with 0 items if:
    *the value of the -Size parameter is 0.

The input list is never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        <dev:type>
          <maml:name>IList</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Permute</maml:name>
        <maml:description>
          <maml:para>Groups items inside a list into permutations.
The number of items in each group is specified with the -Size parameter.
If the -Size parameter is not specified, the number of items in each group is the same as the length of the list.

Note:
This function does not return any groups if:
    *the value of the -Size parameter is less than 0
    *the value of the -Size parameter is greater than the length of the list.

This function will return 1 group with 0 items if:
    *the value of the -Size parameter is 0.

The input list is never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList</command:parameterValue>
        <dev:type>
          <maml:name>IList</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>CartesianProduct</maml:name>
        <maml:description>
          <maml:para>Groups items from 0 or more lists into cartesian products.
Each group has the same number of items as the number of lists specified.

Note:
This function does not return any groups if:
    *no lists are specified
    *any of the specified lists are empty.

The lists do not need to have the same number of items.

The lists (and the list that contains them) are never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList[]</command:parameterValue>
        <dev:type>
          <maml:name>IList[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>CoveringArray</maml:name>
        <maml:description>
          <maml:para>Groups items from 0 or more lists into a filtered output of cartesian product for t-way testing.
Each group has the same number of items as the number of lists specified.

See the -Strength parameter for more details.

Note:
This function does not return any groups if:
    *no lists are specified
    *any of the specified lists are empty
    *the value of the -Strength parameter is negative or 0.

This function will return the cartesian product if:
    *the -Strength parameter is not specified
    *the value of the -Strength parameter is greater than or equal to the number of lists.

The lists do not need to have the same number of items.

The lists (and the list that contains them) are never modified by this function.


Implementation Notes:
    *does not always create the smallest covering array possible
    *repeatable covering array output (no randomization)
    *streaming covering array output (no unnecessary waiting)


=======================================================================
See nist.gov for more details about covering arrays:
    Practical Combinatorial Testing
    by D. Richard Kuhn, Raghu N. Kacker, and Yu Lei
    http://csrc.nist.gov/groups/SNS/acts/documents/SP800-142-101006.pdf

    NIST Covering Array Tables - What is a covering array?
    http://math.nist.gov/coveringarrays/coveringarray.html
=======================================================================</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList[]</command:parameterValue>
        <dev:type>
          <maml:name>IList[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Zip</maml:name>
        <maml:description>
          <maml:para>Groups items from 0 or more lists that have the same index.
Each group has the same number of items as the number of lists specified.

Note:
This function does not return any groups if:
    *no lists are specified
    *any of the specified lists are empty.

If the lists do not have the same number of items, the number of groups in the output is equal to the number of items in the list with the fewest items.

The lists (and the list that contains them) are never modified by this function.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">IList[]</command:parameterValue>
        <dev:type>
          <maml:name>IList[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Size</maml:name>
        <maml:description>
          <maml:para>The number of items per group for combinations, permutations, and windows.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Int32</command:parameterValue>
        <dev:type>
          <maml:name>Int32</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>0</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Strength</maml:name>
        <maml:description>
          <maml:para>The strength of the covering array.

A covering array of strength n is a filtered form of Cartesian product where all n-tuple of values from any n lists appears in at least 1 row of the output.

Example:

    $aList = @('a1','a2')
    $bList = @('b1','b2')
    $cList = @('c1','c2')
    $dList = @('d1','d2','d3')

    group-listItem -coveringArray $aList, $bList, $cList, $dList -strength 2

Outputs the covering array:

    Items
    -----
    {a1, b1, c1, d1}
    {a1, b1, c1, d2}
    {a1, b1, c1, d3}
    {a1, b1, c2, d1}
    {a1, b1, c2, d2}
    {a1, b1, c2, d3}
    {a1, b2, c1, d1}
    {a1, b2, c1, d2}
    {a1, b2, c1, d3}
    {a1, b2, c2, d1}
    {a2, b1, c1, d1}
    {a2, b1, c1, d2}
    {a2, b1, c1, d3}
    {a2, b1, c2, d1}
    {a2, b2, c1, d1}

The covering array above has a strength of 2 because if you take any 2 lists from the input, all the ways that the values from those 2 lists can be grouped appears in one or more rows in the output.
    $aList, $bList: (a1, b1) (a1, b2) (a2, b1) (a2, b2)
    $aList, $cList: (a1, c1) (a1, c2) (a2, c1) (a2, c2)
    $aList, $dList: (a1, d1) (a1, d2) (a1, d3) (a2, d1) (a2, d2) (a2, d3)
    $bList, $cList: (b1, c1) (b1, c2) (b2, c1) (b2, c2)
    $bList, $dList: (b1, d1) (b1, d2) (b1, d3) (b2, d1) (b2, d2) (b2, d3)
    $cList, $dList: (c1, d1) (c1, d2) (c1, d3) (c2, d1) (c2, d2) (c2, d3)

The covering array above DOES NOT have a strength of 3 because if you take any 3 lists from the input, the output DOES NOT contain all the ways that the values from those 3 lists can be grouped.
    $aList, $bList, $cList: (a2, b2, c2) missing
    $aList, $bList, $dList: (a2, b2, d2) (a2, b2, d3) missing
    $aList, $cList, $dList: (a2, c2, d2) (a2, c2, d3) missing
    $bList, $cList, $dList: (b2, c2, d2) (b2, c2, d3) missing

In general, covering arrays with a high strength have more rows than covering arrays with a low strength, and the Cartesian product is a covering array with the highest strength possible.


=======================================================================
See nist.gov for more details about covering arrays:
    Practical Combinatorial Testing
    by D. Richard Kuhn, Raghu N. Kacker, and Yu Lei
    http://csrc.nist.gov/groups/SNS/acts/documents/SP800-142-101006.pdf

    NIST Covering Array Tables - What is a covering array?
    http://math.nist.gov/coveringarrays/coveringarray.html
=======================================================================</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Int32</command:parameterValue>
        <dev:type>
          <maml:name>Int32</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>0</dev:defaultValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Management.Automation.PSCustomObject

The PSCustomObject has a property called 'Items' which will always be an array.

None of the input lists are ever used as the 'Items' property in any of the outputs.

None of the outputs will ever have an 'Items' property that is referentially equal to another 'Items' property from another output.

The array in the 'Items' property has a type of [System.Object[]] by default. However, the 'Items' property may be constrained with a specific type, such as [System.Int32[]], if the list input to -RotateLeft, -RotateRight, -Pair, -Window, -Combine, or -Permute is constrained to a specific type, or if the list inputs to -CartesianProduct or -Zip are constrained to the same specific type.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>Why not output a list of lists?

The ideal output for this function is a list of lists. That would allow, for example, to take the output of (Group-ListItem -Zip ...) and later on, feed it directly as input to (Group-ListItem -Zip ...). This is useful because if you look at multiple lists of the same length as rows and columns of data, then -Zip can be used to transpose the rows into columns, and calling -Zip a second time allows you to "undo" the transpose operation.

This was not done for this function because in PowerShell, functions returning lists can be error-prone when used in a pipeline. Also, by convention, public functions in PowerShell do not return lists, but return the contents of the list one at a time.

If you want the output to be a list of lists, then I suggest you create wrapper functions like this:

    function zip($listOfLists)
    {
        $a = @(Group-ListItem -Zip $listOfLists)
        for ($i = 0; $i -lt $a.length; $i++) {
            $a[$i] = $a[$i].Items
        }
        ,$a
    }

Note that using nested lists in the PowerShell pipeline will cause subtle bugs, so these wrapper functions should never be used in a pipeline and their implementations should never use the pipeline.</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -pair @(10, 20, 30, 40, 50)</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {10, 20}
    {20, 30}
    {30, 40}
    {40, 50}</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -pair $numbers | assert-pipelineall {param($pair) $a, $b = $pair.Items; $a -le $b} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the items in $numbers are sorted in ascending order using the PowerShell -le operator for comparisons.

If $numbers were defined as

    $numbers = @(10, 20, 30, 40, 50)

then the this example is equivalent to

    assert-true (10 -le 20)
    assert-true (20 -le 30)
    assert-true (30 -le 40)
    assert-true (40 -le 50)</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -window @(1, 2, 3, 5, 8, 13, 21) -size 3</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {1, 2, 3}
    {2, 3, 5}
    {3, 5, 8}
    {5, 8, 13}
    {8, 13, 21}</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -window $numbers -size 3 | assert-pipelineall {param($window) $a, $b, $c = $window.Items; ($a + $b) -eq $c} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the numbers in the sequence is the sum of the two previous numbers in the sequence (Fibonacci sequence) using the PowerShell -eq operator for comparisons.

If $numbers were defined as

    $numbers = @(1, 2, 3, 5, 8, 13, 21)

then the example is equivalent to

    assert-true ((1 + 2) -eq 3)
    assert-true ((2 + 3) -eq 5)
    assert-true ((3 + 5) -eq 8)
    assert-true ((5 + 8) -eq 13)
    assert-true ((8 + 13) -eq 21)</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 5 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -rotateLeft @('a', 'b', 'c', $null)</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {a, b, c, $null}
    {b, c, $null, a}
    {c, $null, a, b}
    {$null, a, b, c}

See also the -RotateRight parameter.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 6 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -rotateLeft $strings | assert-pipelineall {param($rotations) (sortedJoin $rotations.Items) -eq 'abc'} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the result of "sortedJoin" will be equal to "abc", regardless of the order items in $strings, using the PowerShell -eq operator for comparisons.

If $strings and sortedJoin were defined as

    $strings = @('a', 'b', 'c', $null)
    function sortedJoin($list) {return ($list | sort-object) -join ''}

then the example is equivalent to

    assert-true ((sortedJoin @('a', 'b', 'c', $null)) -eq 'abc')
    assert-true ((sortedJoin @('b', 'c', $null, 'a')) -eq 'abc')
    assert-true ((sortedJoin @('c', $null, 'a', 'b')) -eq 'abc')
    assert-true ((sortedJoin @($null, 'a', 'b', 'c')) -eq 'abc')

See also the -RotateRight parameter.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 7 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -combine @('a', 'b', 'c', 'd', 'e') -size 3</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {a, b, c}
    {a, b, d}
    {a, b, e}
    {a, c, d}
    {a, c, e}
    {a, d, e}
    {b, c, d}
    {b, c, e}
    {b, d, e}
    {c, d, e}</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 8 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -combine $words -size 3 | assert-pipelineall {param($combinations) ($combinations.Items -join ' ').length -lt 10} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that if any 3 items from $words are joined, the length of the string is less than 10, using the PowerShell -lt operator for comparisons.

If $words were defined as

    $words = @('a', 'b', 'c', 'd', 'e')

then the example is equivalent to

    assert-true (('a', 'b', 'c' -join ' ').length -lt 10)
    assert-true (('a', 'b', 'd' -join ' ').length -lt 10)
    assert-true (('a', 'b', 'e' -join ' ').length -lt 10)
    assert-true (('a', 'c', 'd' -join ' ').length -lt 10)
    assert-true (('a', 'c', 'e' -join ' ').length -lt 10)
    assert-true (('a', 'd', 'e' -join ' ').length -lt 10)
    assert-true (('b', 'c', 'd' -join ' ').length -lt 10)
    assert-true (('b', 'c', 'e' -join ' ').length -lt 10)
    assert-true (('b', 'd', 'e' -join ' ').length -lt 10)
    assert-true (('c', 'd', 'e' -join ' ').length -lt 10)</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 9 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -permute @(10, 20, 30)</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {10, 20, 30}
    {10, 30, 20}
    {20, 10, 30}
    {20, 30, 10}
    {30, 10, 20}
    {30, 20, 10}</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 10 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -permute $numbers | assert-pipelineall {param($permutations) (add $permutations.Items) -eq 60} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the result of "add" will be equal to 60, regardless of the order of the items in $numbers, using the PowerShell -eq operator for comparisons.

If $numbers and add were defined as

    $numbers = @(10, 20, 30)
    function add($list) {return ($list | measure -sum).sum}

then the example is equivalent to

    assert-true ((add @(10, 20, 30)) -eq 60)
    assert-true ((add @(10, 30, 20)) -eq 60)
    assert-true ((add @(20, 10, 30)) -eq 60)
    assert-true ((add @(20, 30, 10)) -eq 60)
    assert-true ((add @(30, 10, 20)) -eq 60)
    assert-true ((add @(30, 20, 10)) -eq 60)</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 11 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -cartesianProduct @(0), @(-2, -1, 0, 1, 2), @('stop', 'silentlycontinue')</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {0, -2, stop}
    {0, -2, silentlycontinue}
    {0, -1, stop}
    {0, -1, silentlycontinue}
    {0, 0, stop}
    {0, 0, silentlycontinue}
    {0, 1, stop}
    {0, 1, silentlycontinue}
    {0, 2, stop}
    {0, 2, silentlycontinue}</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 12 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -cartesianProduct @(0), $numbers, $ea | assert-pipelineall {param($cProduct) $a, $b, $c = $cProduct.Items; (add $a $b -erroraction $c) -eq $b} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the result of (add 0 $number) is equal to $number, using the PowerShell -eq operator for comparisons.

If $numbers, $ea, and add were defined as

    $numbers = @(-2, -1, 0, 1, 2)
    $ea = @('stop', 'silentlycontinue')
    function add {[cmdletbinding()]param($a, $b) return $a + $b}

then the example is equivalent to

    assert-true ((add 0 -2 -erroraction stop) -eq -2)
    assert-true ((add 0 -2 -erroraction silentlycontinue) -eq -2)
    assert-true ((add 0 -1 -erroraction stop) -eq -1)
    assert-true ((add 0 -1 -erroraction silentlycontinue) -eq -1)
    assert-true ((add 0 0 -erroraction stop) -eq 0)
    assert-true ((add 0 0 -erroraction silentlycontinue) -eq 0)
    assert-true ((add 0 1 -erroraction stop) -eq 1)
    assert-true ((add 0 1 -erroraction silentlycontinue) -eq 1)
    assert-true ((add 0 2 -erroraction stop) -eq 2)
    assert-true ((add 0 2 -erroraction silentlycontinue) -eq 2)</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 13 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -coveringArray @('a1','a2','a3'), @('b1','b2','b3','b4','b5'), @('c1','c2') -strength 1</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {a1, b1, c1}
    {a2, b2, c2}
    {a3, b3, c1}
    {a1, b4, c2}
    {a2, b5, c1}

Notice the following:
    *a1, a2, and a3 all appear in at least one row
    *b1, b2, b3, b4, and b5 all appear in at least one row
    *c1 and c2 all appear in at least one row

See the -Strength parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 14 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -coveringArray $aList, $bList, $cList -strength 1 | assert-pipelineall {param($cArray) $a, $b, $c = $cArray.Items; $null -ne (f $a $b $c)} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the result of (f $a $b $c) is never $null, using the covering array of strength 1 generated from the lists.

If $aList, $bList, $cList, and f were defined as

    $aList = @('a1','a2','a3')
    $bList = @('b1','b2','b3','b4','b5')
    $cList = @('c1','c2')
    function f($a, $b, $c) {"$a $b $c"}

then the example is equivalent to

    assert-true ($null -ne (f 'a1' 'b1' 'c1'))
    assert-true ($null -ne (f 'a2' 'b2' 'c2'))
    assert-true ($null -ne (f 'a3' 'b3' 'c1'))
    assert-true ($null -ne (f 'a1' 'b4' 'c2'))
    assert-true ($null -ne (f 'a2' 'b5' 'c1'))</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 15 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -zip @('a', 'b', 'c'), @(1, 2, 3, 4, 5)</dev:code>
        <dev:remarks>
          <maml:para>Outputs the following arrays:

    Items
    -----
    {a, 1}
    {b, 2}
    {c, 3}

Note:
Zip takes 0 or more lists, and the list with the fewest items determines the number of arrays that zip outputs.

In this example, the list with the fewest items (@('a', 'b', 'c')) only has 3 items, so zip outputs 3 arrays.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 16 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>group-listItem -zip $aList, $bList | assert-pipelineall {param($zipped) $a, $b = $zipped.Items; $a -eq $b} | out-null</dev:code>
        <dev:remarks>
          <maml:para>Asserts that the first items in $aList are equal to the first items in $bList using the PowerShell -eq operator for comparisons.

If $aList and $bList were defined as

    $aList = @(1, 2, 3, 4, 5)
    $bList = @(1, 2, 3, 4, 5, 6, 7, 8, 9)

then the example is equivalent to

    assert-true (1 -eq 1)
    assert-true (2 -eq 2)
    assert-true (3 -eq 3)
    assert-true (4 -eq 4)
    assert-true (5 -eq 5)</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineAll</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineNotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Assert-PipelineCount</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-All</command:name>
      <maml:description>
        <maml:para>Test that a predicate is true for all items in a collection.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>All</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a predicate is $true for all items in a collection.

    Return Value   Condition
    ------------   ---------
    $null          the collection is not of type System.Collections.ICollection
    $false         the predicate never returns the System.Boolean value $true
    $true          the predicate always returns the System.Boolean value $true
                   the collection is empty

*See the -Collection and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-All</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Collection</maml:name>
          <maml:description>
            <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Collection</maml:name>
        <maml:description>
          <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'all?' 'test-all'

assert-all    $items {param($a) all? $a.bArray {param($b) $b -gt 10}}
assert-exists $items {param($a) all? $a.cArray {param($c) $c -eq 0}}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-All @(1, 2, 3, 4, 5) {param($n) $n -gt 0}</dev:code>
        <dev:remarks>
          <maml:para>Test that all items in the array are greater than 0.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-All @() {param($n) $n -gt 0}</dev:code>
        <dev:remarks>
          <maml:para>Test that all items in the array are greater than 0.

Note:
This test will always return $true because the array is empty.
This is known as vacuous truth.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-All @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -gt 5}</dev:code>
        <dev:remarks>
          <maml:para>Test that all entries in the hashtable have a value greater than 5.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-DateTime</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison operators when testing DateTime objects in unit test scenarios.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>DateTime</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests a DateTime object for type and equality without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid test. See each parameter for specific conditions that causes this function to return $true, $false, or $null.

Note about calendars
====================
The documentation for System.DateTime explicitly states the use of the Gregorian calendar in some of its properties. This function uses the same calendar that the System.DateTime class uses.

This function does not support the use of different calendars.

Note about time zones
=====================
The System.DateTime class has limited support for time zones. Specifically, the DateTime class can represent dates and times in UTC, local time, or some unspecified time zone.

This function does NOT normalize dates and times to a common time zone before performing comparisons.

This function does NOT take time zone information into consideration when performing comparisons.

See the -Kind and -MatchKind parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsDateTime</maml:name>
          <maml:description>
            <maml:para>Tests if the value is a DateTime value.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a DateTime*
$true          value is a DateTime*

*See the -Kind and -MatchKind parameters for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) != 0
$true          System.DateTime.Compare(DateTime, DateTime) == 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchKind</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) == 0
$true          System.DateTime.Compare(DateTime, DateTime) != 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchKind</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &gt;= 0
$true          System.DateTime.Compare(DateTime, DateTime) &lt; 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchKind</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &gt; 0
$true          System.DateTime.Compare(DateTime, DateTime) &lt;= 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchKind</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &lt;= 0
$true          System.DateTime.Compare(DateTime, DateTime) &gt; 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchKind</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-DateTime</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &lt; 0
$true          System.DateTime.Compare(DateTime, DateTime) &gt;= 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchKind</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Kind</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsDateTime</maml:name>
        <maml:description>
          <maml:para>Tests if the value is a DateTime value.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a DateTime*
$true          value is a DateTime*

*See the -Kind and -MatchKind parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) != 0
$true          System.DateTime.Compare(DateTime, DateTime) == 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) == 0
$true          System.DateTime.Compare(DateTime, DateTime) != 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &gt;= 0
$true          System.DateTime.Compare(DateTime, DateTime) &lt; 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &gt; 0
$true          System.DateTime.Compare(DateTime, DateTime) &lt;= 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &lt;= 0
$true          System.DateTime.Compare(DateTime, DateTime) &gt; 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a DateTime*
$false         System.DateTime.Compare(DateTime, DateTime) &lt; 0
$true          System.DateTime.Compare(DateTime, DateTime) &gt;= 0

*See the -Kind and -MatchKind parameters for more details.

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>MatchKind</maml:name>
        <maml:description>
          <maml:para>Causes the comparison of two DateTimes to return $null if they do not have the same kind.

*See the -Kind parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Kind</maml:name>
        <maml:description>
          <maml:para>One or more Enums that can be used to define which kind of DateTime objects are to be considered DateTime objects.

The Kind property of a DateTime object states whether the DateTime object is a Local time, a UTC time, or an Unspecified time.

Note:
DateTime objects are not normalized to a common Kind before performing comparisons.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-DateTime objects.

PowerShell Note:
Get-Date returns DateTime objects in Local time.

For example:
    $local = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::local)
    $utc   = new-object 'datetime' 2014, 1, 1, 0, 0, 0, ([datetimekind]::utc)

    #$local  is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind utc
    test-datetime $local -eq $utc -Kind utc, unspecified

    #$utc is not considered as a DateTime object
    #
    test-datetime $local -eq $utc -Kind local
    test-datetime $local -eq $utc -Kind local, unspecified

    #$utc and $local are considered as DateTime objects
    #
    test-datetime $local -eq $utc -Kind local, utc
    test-datetime $local -eq $utc -Kind utc, local
    test-datetime $local -eq $utc -Kind utc, local, unspecified
    test-datetime $local -eq $utc

WARNING
=======
If you run the example above, you will notice that $local and $utc are considered EQUAL.

This means that the comparisons DO NOT take time zone information into consideration.

Part of the reason for this is that DateTime objects can be used to represent many concepts of time:
    *a time (12:00 AM)
    *a date (January 1)
    *a date and time (January 1 12:00 AM)
    *a specific date and time (2015 January 1 12:00 AM)
    *a specific date and time at a specific place (2015 January 1 12:00 AM UTC)
    *a weekly date and time (Weekdays 9:00 AM)
    *a monthly date (every first Friday)
    *a yearly date (every January 1st)
    *and so on...

So, the meaning of the comparisons in the example above is not,
    "Does $local and $utc represent the same moment in time?",
but
    "Does $local and $utc both represent the same date and time values?".</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">DateTimeKind[]</command:parameterValue>
        <dev:type>
          <maml:name>DateTimeKind[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Property</maml:name>
        <maml:description>
          <maml:para>Compares the DateTime values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Year, Month, Day, Hour, Minute, Second, Millisecond, Date, TimeOfDay, DayOfWeek, DayOfYear, Ticks, Kind

No wildcards are allowed.
No calculated properties are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two DateTime objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

Note:
Synthetic properties are not used in comparisons.
For example, when the year property is compared, an expression like $a.psbase.year is used instead of $a.year.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        <dev:type>
          <maml:name>String[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'datetime?' 'test-datetime'

#if you have an assert function, you can write assertions like this
assert (datetime? $a)
assert (datetime? $a -kind utc)
assert (datetime? $a -eq $b -matchkind -kind utc, local)
assert (datetime? $a -eq $b -matchkind -kind utc, local -property year, month, day)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-DateTime $a</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a DateTime object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-DateTime $a -kind utc</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a DateTime object with a value of utc for its Kind property.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-DateTime $a -eq $b</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both DateTime objects with the same value (excluding the Kind property).
Returns $null if $a or $b is not a DateTime object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-DateTime $a -eq $b -matchkind</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both DateTime objects with the same value and the same Kind.
Returns $null if $a or $b is not a DateTime object, or $a and $b do not have the same Kind.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 5 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-DateTime $a -eq $b -property year, month, day</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both DateTime objects with the same year, month, and day values.
Returns $null if $a or $b is not a DateTime object.

Note that the order of the properties specified is significant. See the -Property parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-Guid</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Number</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-String</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Text</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-TimeSpan</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Version</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-Exists</command:name>
      <maml:description>
        <maml:para>Test that a predicate is true for some of the items in a collection.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>Exists</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a predicate is $true for some of the items in a collection.

    Return Value   Condition
    ------------   ---------
    $null          the collection is not of type System.Collections.ICollection
    $false         the predicate never returns the System.Boolean value $true
                   the collection is empty
    $true          the predicate returns the System.Boolean value $true one or more times

*See the -Collection and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-Exists</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Collection</maml:name>
          <maml:description>
            <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Collection</maml:name>
        <maml:description>
          <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'exists?' 'test-exists'

assert-all    $items {param($a) exists? $a.bArray {param($b) $b -gt 10}}
assert-exists $items {param($a) exists? $a.cArray {param($c) $c -eq 0}}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Exists @(1, 2, 3, 4, 5) {param($n) $n -gt 3}</dev:code>
        <dev:remarks>
          <maml:para>Test that at least one item in the array is greater than 3.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Exists @() {param($n) $n -gt 3}</dev:code>
        <dev:remarks>
          <maml:para>Test that at least one item in the array is greater than 3.

Note:
This test will always return $false because the array is empty.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Exists @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -gt 25}</dev:code>
        <dev:remarks>
          <maml:para>Test that at least one entry in the hashtable has a value greater than 25.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-False</command:name>
      <maml:description>
        <maml:para>Test that a value is the Boolean value $false.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>False</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a value is $false without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

    Return Value   Condition
    ------------   ---------
    $null          never
    $false         value is not of type System.Boolean
                   value is not $false
    $true          value is $false</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-False</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'false?' 'test-false'

assert-all    $items {param($a) (false? $a.b) -and (false? $a.c)}
assert-exists $items {param($a) (false? $a.d) -xor (false? $a.e)}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-False 0</dev:code>
        <dev:remarks>
          <maml:para>Test if the number 0 is $false without performing any implicit conversions.

Note:
Compare the example above with the following expressions:
    0 -eq $false
    '0' -eq $false
and see how tests can become confusing if those numbers were stored in variables.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-False @($false)</dev:code>
        <dev:remarks>
          <maml:para>Test if the array is $false without filtering semantics.

Note:
Compare the example above with the following expressions:
    @(0, $false) -eq $false
    @(-1, 0, 1, 2, 3) -eq $false
and see how tests can become confusing if the value is stored in a variable or if the value is not expected to be an array.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-Guid</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison operators when testing GUIDs in unit test scenarios.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>Guid</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests a GUID for type and equality without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid test. See each parameter for specific conditions that causes this function to return $true, $false, or $null.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsGuid</maml:name>
          <maml:description>
            <maml:para>Tests if the value is a GUID.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a GUID*
$true          value is a GUID*

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) != 0
$true          System.Guid method CompareTo(Guid) == 0

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVariant</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVersion</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) == 0
$true          System.Guid method CompareTo(Guid) != 0

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVariant</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVersion</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &gt;= 0
$true          System.Guid method CompareTo(Guid) &lt; 0

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVariant</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVersion</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &gt; 0
$true          System.Guid method CompareTo(Guid) &lt;= 0

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVariant</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVersion</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &lt;= 0
$true          System.Guid method CompareTo(Guid) &gt; 0

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVariant</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVersion</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Guid</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &lt; 0
$true          System.Guid method CompareTo(Guid) &gt;= 0

*See the -Variant and -Version parameters for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVariant</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchVersion</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Variant</maml:name>
          <maml:description>
            <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Version</maml:name>
          <maml:description>
            <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsGuid</maml:name>
        <maml:description>
          <maml:para>Tests if the value is a GUID.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a GUID*
$true          value is a GUID*

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) != 0
$true          System.Guid method CompareTo(Guid) == 0

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) == 0
$true          System.Guid method CompareTo(Guid) != 0

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &gt;= 0
$true          System.Guid method CompareTo(Guid) &lt; 0

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &gt; 0
$true          System.Guid method CompareTo(Guid) &lt;= 0

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &lt;= 0
$true          System.Guid method CompareTo(Guid) &gt; 0

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a GUID*
$false         System.Guid method CompareTo(Guid) &lt; 0
$true          System.Guid method CompareTo(Guid) &gt;= 0

*See the -Variant and -Version parameters for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>MatchVariant</maml:name>
        <maml:description>
          <maml:para>Causes the comparison of two GUIDs to return $null if they do not have an equivalent variant.

*See the -Variant parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>MatchVersion</maml:name>
        <maml:description>
          <maml:para>Causes the comparison of two GUIDs to return $null if they do not have the same value in their version fields.

*See the -Version parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Variant</maml:name>
        <maml:description>
          <maml:para>One or more Strings that can be used to define which variants of GUIDs are to be considered GUIDs.

Allowed Variants
----------------
Standard, Microsoft, NCS, Reserved

    The GUID variant field can be found in the nibble marked with v:
    00000000-0000-0000-v000-000000000000

    Variant    v
    -------    -
    Standard   8, 9, A, B
    Microsoft  C, D
    NCS        0, 1, 2, 3, 4, 5, 6, 7
    Reserved   E, F

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        <dev:type>
          <maml:name>String[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Version</maml:name>
        <maml:description>
          <maml:para>One or more integers that can be used to define which versions of GUIDs are to be considered GUIDs.

Allowed Versions
----------------
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15

    The GUID version field can be found in the nibble marked with v:
    00000000-0000-v000-0000-000000000000

    Note: The meaning of the value in the version field depends on the GUID variant.

Note:
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-GUIDs.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">Int32[]</command:parameterValue>
        <dev:type>
          <maml:name>Int32[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'guid?' 'test-guid'

assert-true (guid? $a)
assert-true (guid? $a -variant standard -version 1,3,4,5)
assert-true (guid? $a -ne $b -variant standard -version 1,3,4,5 -matchvariant -matchversion)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Guid $a</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a GUID.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Guid $a -variant standard, microsoft</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a standard variant GUID or a Microsoft Backward Compatibility variant GUID.

See the -Variant parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Guid $a -variant standard -version 1, 4</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a standard variant GUID, with a value of 1 or 4 in its version field.

See the -Variant and -Version parameters for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Guid $a -lt $b</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is less than $b, and $a and $b are both GUIDs.
Returns $null if $a or $b is not a GUID.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 5 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Guid $a -lt $b -matchvariant</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is less than $b, and $a and $b have equivalent values in their variant field.
Returns $null if $a or $b is not a GUID, or $a and $b do not have equivalent values in their variant field.

See the -MatchVariant and -Variant parameters for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 6 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Guid $a -lt $b -variant standard -matchversion</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is less than $b, and both $a and $b are standard variant GUIDs with the same value in their version field.
Returns $null if $a or $b is not a standard variant GUID, or $a and $b do not have the same value in their version field.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-DateTime</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Number</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-String</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Text</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-TimeSpan</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Version</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-NotExists</command:name>
      <maml:description>
        <maml:para>Test that a predicate is never true for any item in a collection.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>NotExists</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a predicate is never $true for any item in a collection.

    Return Value   Condition
    ------------   ---------
    $null          the collection is not of type System.Collections.ICollection
    $false         the predicate returns the System.Boolean value $true one or more times
    $true          the predicate never returns the System.Boolean value $true
                   the collection is empty

*See the -Collection and -Predicate parameters for more details.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-NotExists</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Collection</maml:name>
          <maml:description>
            <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
          <maml:name>Predicate</maml:name>
          <maml:description>
            <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Collection</maml:name>
        <maml:description>
          <maml:para>The collection of items used to test the predicate.

The order in which the items in the collection are tested is determined by the collection's GetEnumerator method.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="2" aliases="">
        <maml:name>Predicate</maml:name>
        <maml:description>
          <maml:para>The script block that will be invoked on each item in the collection.

The script block must take one argument and return a value.

Note:
The -ErrorAction parameter has NO effect on the predicate.
An InvalidOperationException is thrown if the predicate throws an error.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">ScriptBlock</command:parameterValue>
        <dev:type>
          <maml:name>ScriptBlock</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'notExists?' 'test-notexists'

assert-all    $items {param($a) notExists? $a.bArray {param($b) $b -gt 10}}
assert-exists $items {param($a) notExists? $a.cArray {param($c) $c -eq 0}}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotExists @(1, 2, 3, 4, 5) {param($n) $n -gt 10}</dev:code>
        <dev:remarks>
          <maml:para>Test that no item in the array is greater than 10.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotExists @() {param($n) $n -gt 10}</dev:code>
        <dev:remarks>
          <maml:para>Test that no item in the array is greater than 10.

Note:
This test will always return $true because the array is empty.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotExists @{a0 = 10; a1 = 20; a2 = 30} {param($entry) $entry.Value -lt 0}</dev:code>
        <dev:remarks>
          <maml:para>Test that no entry in the hashtable has a value less than 0.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-NotFalse</command:name>
      <maml:description>
        <maml:para>Test that a value is not the Boolean value $false.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>NotFalse</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a value is not $false without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

    Return Value   Condition
    ------------   ---------
    $null          never
    $false         value is the System.Boolean value $false
    $true          value is not of type System.Boolean
                   value is $true</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-NotFalse</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'notFalse?' 'test-notfalse'

assert-all    $items {param($a) (notFalse? $a.b) -and (notFalse? $a.c)}
assert-exists $items {param($a) (notFalse? $a.d) -xor (notFalse? $a.e)}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotFalse 0</dev:code>
        <dev:remarks>
          <maml:para>Test if the number 0 is not $false without performing any implicit conversions.

Note:
Compare the example above with the following expressions:
    0 -ne $false
    '0' -ne $false
and see how tests can become confusing if those numbers were stored in variables.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotFalse @($false)</dev:code>
        <dev:remarks>
          <maml:para>Test if the array is not $false without filtering semantics.

Note:
Compare the example above with the following expressions:
    @(0, $false) -ne $false
    @(-1, 0, 1, 2, 3) -ne $false
and see how tests can become confusing if the value is stored in a variable or if the value is not expected to be an array.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-NotNull</command:name>
      <maml:description>
        <maml:para>Test that a value is not $null.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>NotNull</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a value is not $null without the filtering semantics from the PowerShell comparison operators.

    Return Value   Condition
    ------------   ---------
    $null          never
    $false         value is $null
    $true          value is not $null</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-NotNull</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'notNull?' 'test-notnull'

assert-all    $items {param($a) (notNull? $a.b) -and (notNull? $a.c)}
assert-exists $items {param($a) (notNull? $a.d) -xor (notNull? $a.e)}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotNull @(1)</dev:code>
        <dev:remarks>
          <maml:para>Test if the value is not $null without filtering semantics.

Note:
Compare the example above with the following expressions:
    10 -ne $null
    @(10) -ne $null
and see how tests can become confusing if the value is stored in a variable or if the value is not expected to be an array.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-NotTrue</command:name>
      <maml:description>
        <maml:para>Test that a value is not the Boolean value $true.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>NotTrue</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a value is not $true without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

    Return Value   Condition
    ------------   ---------
    $null          never
    $false         value is the System.Boolean value $true
    $true          value is not of type System.Boolean
                   value is $false</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-NotTrue</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'notTrue?' 'test-notTrue'

assert-all    $items {param($a) (notTrue? $a.b) -and (notTrue? $a.c)}
assert-exists $items {param($a) (notTrue? $a.d) -xor (notTrue? $a.e)}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotTrue 1</dev:code>
        <dev:remarks>
          <maml:para>Test if the number 1 is not $true without performing any implicit conversions.

Note:
Compare the example above with the following expressions:
    1 -ne $true
    10 -ne $true
and see how tests can become confusing if those numbers were stored in variables.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-NotTrue @($true)</dev:code>
        <dev:remarks>
          <maml:para>Test if the array is not $true without filtering semantics.

Note:
Compare the example above with the following expressions:
    @(1, $true) -ne $true
    @(-1, 0, 1, 2, 3) -ne $true
and see how tests can become confusing if the value is stored in a variable or if the value is not expected to be an array.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-Null</command:name>
      <maml:description>
        <maml:para>Test that a value is $null.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>Null</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a value is $null without the filtering semantics from the PowerShell comparison operators.

    Return Value   Condition
    ------------   ---------
    $null          never
    $false         value is not $null
    $true          value is $null</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-Null</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'null?' 'test-null'

assert-all    $items {param($a) (null? $a.b) -and (null? $a.c)}
assert-exists $items {param($a) (null? $a.d) -xor (null? $a.e)}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Null @(1)</dev:code>
        <dev:remarks>
          <maml:para>Test if the value is $null without filtering semantics.

Note:
Compare the example above with the following expressions:
    1 -eq $null
    @(1) -eq $null
and see how tests can become confusing if the value is stored in a variable or if the value is not expected to be an array.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-True</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-Number</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison operators when testing numbers in unit test scenarios.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>Number</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests a number for type and equality without the filtering semantics of the PowerShell comparison operators.

This function also gives you some control over how different types of numbers should be compared. See the -Type and -MatchType parameters for more details.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid test. See each parameter for specific conditions that causes this function to return $true, $false, or $null.

Note:
NaN, PositiveInfinity, and NegativeInfinity are not considered to be numbers by this function.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsNumber</maml:name>
          <maml:description>
            <maml:para>Tests if the value is a number.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a number*
$true          value is a number*

* See -Type parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -eq operator returns $false
$true          PowerShell's -eq operator returns $true

* See -Type parameter for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchType</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -ne operator returns $false
$true          PowerShell's -ne operator returns $true

* See -Type parameter for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchType</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -lt operator returns $false
$true          PowerShell's -lt operator returns $true

* See -Type parameter for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchType</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -le operator returns $false
$true          PowerShell's -le operator returns $true

* See -Type parameter for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchType</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -gt operator returns $false
$true          PowerShell's -gt operator returns $true

* See -Type parameter for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchType</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Number</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -ge operator returns $false
$true          PowerShell's -ge operator returns $true

* See -Type parameter for more details.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>MatchType</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Type</maml:name>
          <maml:description>
            <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsNumber</maml:name>
        <maml:description>
          <maml:para>Tests if the value is a number.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a number*
$true          value is a number*

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -eq operator returns $false
$true          PowerShell's -eq operator returns $true

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -ne operator returns $false
$true          PowerShell's -ne operator returns $true

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -lt operator returns $false
$true          PowerShell's -lt operator returns $true

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -le operator returns $false
$true          PowerShell's -le operator returns $true

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -gt operator returns $false
$true          PowerShell's -gt operator returns $true

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a number*
               -MatchType is set and values are not of the same type
$false         PowerShell's -ge operator returns $false
$true          PowerShell's -ge operator returns $true

* See -Type parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>MatchType</maml:name>
        <maml:description>
          <maml:para>Causes the comparison of two numbers to return $null if they do not have the same type.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Type</maml:name>
        <maml:description>
          <maml:para>One or more strings that can be used to define which numeric types are to be considered numeric types.

These types are considered to be numeric types:
   System.Byte, System.SByte,
   System.Int16, System.Int32, System.Int64,
   System.UInt16, System.UInt32, System.UInt64,
   System.Single, System.Double, System.Decimal, System.Numerics.BigInteger

You can use this parameter to specify which of the types above are to be considered numeric types.

Each type can be specified by its type name or by its full type name.

Note:
NaN, PositiveInfinity, and NegativeInfinity are never considered to be numbers by this function.
Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-numbers.

For example:
    $a = [uint32]0
    $b = [double]10.0

    #$a (uint32) is not considered a number
    #
    Test-Number $a -lt $b -Type Double
    Test-Number $a -lt $b -Type Double, Decimal
    Test-Number $a -lt $b -Type Double, Decimal, Int32
    Test-Number $a -lt $b -Type Double, Decimal, System.Int32

    #$b (double) is not considered a number
    #
    Test-Number $a -lt $b -Type UInt32
    Test-Number $a -lt $b -Type UInt32, Byte
    Test-Number $a -lt $b -Type UInt32, Byte, Int64
    Test-Number $a -lt $b -Type UInt32, System.Byte, Int64

    #$a and $b are considered numbers
    #
    Test-Number $a -lt $b
    Test-Number $a -lt $b -Type UInt32, Double
    Test-Number $a -lt $b -Type Double, UInt32
    Test-Number $a -lt $b -Type Byte, Double, System.SByte, System.UInt32</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        <dev:type>
          <maml:name>String[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'number?' 'test-number'

#if you have an assert function, you can write assertions like this
assert (number? $n)
assert (number? $x -lt $y)
assert (number? $x -lt $y -MatchType)
assert (number? $x -lt $y -Type Int32, Int64, Decimal, Double)
assert (number? $x -lt $y -Type Int32, Int64, Decimal, Double -MatchType)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Number $n</dev:code>
        <dev:remarks>
          <maml:para>Tests if $n is a number.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Number $n -Type Int32</dev:code>
        <dev:remarks>
          <maml:para>Tests if $n is a number of type Int32.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Number $n -Type Int32, Double, Decimal</dev:code>
        <dev:remarks>
          <maml:para>Tests if $n is a number of type Int32, Double, or Decimal.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Number $x -lt $y</dev:code>
        <dev:remarks>
          <maml:para>Returns the result of ($x -lt $y) if $x and $y are numbers.
Returns $null if $x or $y is not a number.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 5 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Number $x -lt $y -MatchType</dev:code>
        <dev:remarks>
          <maml:para>Returns the result of ($x -lt $y) if $x and $y are numbers of the same type.
Returns $null if $x or $y is not a number, or $x and $y do not have the same type.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 6 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Number $x -lt $y -Type Int32, Int64, Double</dev:code>
        <dev:remarks>
          <maml:para>Returns the result of ($x -lt $y) if both $x and $y are numbers of type Int32, Int64, or Double.
Returns $null if $x or $y is not of type Int32, Int64, or Double.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-DateTime</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Guid</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-String</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Text</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-TimeSpan</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Version</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-String</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison functions when testing strings in unit test scenarios.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>String</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests a string for type and equality without the implicit conversions and filtering semantics of the PowerShell comparison operators.

This function also gives you some control over how strings should be compared. See the -Normalization and -FormCompatible parameters for more details.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid test. See each parameter for specific conditions that causes this function to return $true, $false, or $null.

Note about comparison
---------------------
This function uses the Equals and Compare methods from the String class using an ordinal comparison type. This type of comparison will compare strings at the binary level, and this type of comparison is not affected by the user's culture or language settings.

By default this function uses a case-insensitive comparison, but this can be changed by setting the -CaseSensitive switch.

Note about normalization
------------------------
This function does not normalize strings to a common form before performing comparisons.

This is done so that minor deviations from the strings being tested will be detected from unit tests. This is especially important if the strings being tested represent things like file paths or registry keys.

Differences with PowerShell string comparison
---------------------------------------------
For case-sensitive string comparisons, this function may give a different result than the PowerShell comparison operators.

    #PowerShell returns $true
    'A' -cgt 'a'

    #Test-String returns $false
    Test-String 'A' -gt 'a' -CaseSensitive
    
    #String.Compare returns $false
    [string]::compare('A', 'a', [stringcomparison]::Ordinal) -gt 0

    #Int values of characters; returns $false
    [int][char]'A' -gt [int][char]'a'</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsString</maml:name>
          <maml:description>
            <maml:para>Tests if the value is a string.

Return Value   Condition
------------   ---------
$null          never
$false         the value is not a string*
$true          the value is a string*

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Contains</maml:name>
          <maml:description>
            <maml:para>Tests if the first string contains the second.

Note: The empty string is inside all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method IndexOf(String, StringComparison) &lt; 0
$true          String method IndexOf(String, StringComparison) &gt;= 0

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotContains</maml:name>
          <maml:description>
            <maml:para>Tests if the string does not contain the second.

Note: The empty string is inside all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method IndexOf(String, StringComparison) &gt;= 0
$true          String method IndexOf(String, StringComparison) &lt; 0

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>StartsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first string starts with the second string.

Note: The empty string starts all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method StartsWith(String, StringComparison) returns $false
$true          String method StartsWith(String, StringComparison) returns $true

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotStartsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first string does not start with the second string.

Note: The empty string starts all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method StartsWith(String, StringComparison) returns $true
$true          String method StartsWith(String, StringComparison) returns $false

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>EndsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first string ends with the second string.

Note: The empty string ends all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method EndsWith(String, StringComparison) returns $false
$true          String method EndsWith(String, StringComparison) returns $true

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotEndsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first string does not end with the second string

Note: The empty string ends all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method EndsWith(String, StringComparison) returns $true
$true          String method EndsWith(String, StringComparison) returns $false

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Equals(String, String, StringComparison) returns $false
$true          String.Equals(String, String, StringComparison) returns $true

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Equals(String, String, StringComparison) returns $true
$true          String.Equals(String, String, StringComparison) returns $false

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &gt;= 0
$true          String.Compare(String, String, StringComparison) &lt; 0

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &gt; 0
$true          String.Compare(String, String, StringComparison) &lt;= 0

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &lt;= 0
$true          String.Compare(String, String, StringComparison) &gt; 0

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-String</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &lt; 0
$true          String.Compare(String, String, StringComparison) &gt;= 0

*See the -Normalization parameter for more details</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>FormCompatible</maml:name>
          <maml:description>
            <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Normalization</maml:name>
          <maml:description>
            <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsString</maml:name>
        <maml:description>
          <maml:para>Tests if the value is a string.

Return Value   Condition
------------   ---------
$null          never
$false         the value is not a string*
$true          the value is a string*

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Contains</maml:name>
        <maml:description>
          <maml:para>Tests if the first string contains the second.

Note: The empty string is inside all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method IndexOf(String, StringComparison) &lt; 0
$true          String method IndexOf(String, StringComparison) &gt;= 0

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotContains</maml:name>
        <maml:description>
          <maml:para>Tests if the string does not contain the second.

Note: The empty string is inside all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method IndexOf(String, StringComparison) &gt;= 0
$true          String method IndexOf(String, StringComparison) &lt; 0

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>StartsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first string starts with the second string.

Note: The empty string starts all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method StartsWith(String, StringComparison) returns $false
$true          String method StartsWith(String, StringComparison) returns $true

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotStartsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first string does not start with the second string.

Note: The empty string starts all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method StartsWith(String, StringComparison) returns $true
$true          String method StartsWith(String, StringComparison) returns $false

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>EndsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first string ends with the second string.

Note: The empty string ends all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method EndsWith(String, StringComparison) returns $false
$true          String method EndsWith(String, StringComparison) returns $true

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotEndsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first string does not end with the second string

Note: The empty string ends all strings.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String method EndsWith(String, StringComparison) returns $true
$true          String method EndsWith(String, StringComparison) returns $false

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Equals(String, String, StringComparison) returns $false
$true          String.Equals(String, String, StringComparison) returns $true

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Equals(String, String, StringComparison) returns $true
$true          String.Equals(String, String, StringComparison) returns $false

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &gt;= 0
$true          String.Compare(String, String, StringComparison) &lt; 0

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &gt; 0
$true          String.Compare(String, String, StringComparison) &lt;= 0

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &lt;= 0
$true          String.Compare(String, String, StringComparison) &gt; 0

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a string*
$false         String.Compare(String, String, StringComparison) &lt; 0
$true          String.Compare(String, String, StringComparison) &gt;= 0

*See the -Normalization parameter for more details</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>CaseSensitive</maml:name>
        <maml:description>
          <maml:para>Makes the comparisons case sensitive.

If this switch is set, the comparisons use

    [System.StringComparison]::Ordinal

otherwise, the comparisons use

    [System.StringComparison]::OrdinalIgnoreCase

as the default.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>FormCompatible</maml:name>
        <maml:description>
          <maml:para>Causes the comparison of two strings to return $null if they are not normalized to compatible forms.

See the -Normalization parameter for more details.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Normalization</maml:name>
        <maml:description>
          <maml:para>One or more Enums that can be used to define which form of strings are to be considered strings.

Normalization is a way of making sure that a Unicode character will only have one binary representation. This allows strings to be compared using only their binary representations. Comparing strings using only their binary representation is often desirable in scripts and programs because these comparisons are not affected by the rules of different cultures and languages.

The Normalization Forms are: FormC, FormD, FormKC, and FormKD.

You can use this parameter to specify which of the forms above a string must have in order for the string to be considered a string.

Note:
* Specifying this parameter with a $null or an empty array will cause this function to treat all objects as non-strings.

* This function does not normalize strings to a common form before performing the comparison.

Reference:
For more details, see the MSDN documentation for the System.String methods called Normalize() and IsNormalized().</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">NormalizationForm[]</command:parameterValue>
        <dev:type>
          <maml:name>NormalizationForm[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'string?' 'test-string'

#if you have an assert function, you can write assertions like this
assert (string? $a)
assert (string? $a -contains $b)
assert (string? $a -notStartsWith $c -casesensitive -formcompatible)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-String $a</dev:code>
        <dev:remarks>
          <maml:para>Tests if $a is a string.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-String $a -eq $b</dev:code>
        <dev:remarks>
          <maml:para>Tests if $a is equal to $b using a case-insensitive test.

Returns the result of ([string]::Equals($a, $b, [stringcomparison]::ordinalignorecase)) if $a and $b are strings.
Returns $null if $a or $b is not a string.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-String $a -eq $b -CaseSensitive</dev:code>
        <dev:remarks>
          <maml:para>Tests if $a is equal to $b using a case-sensitive test.

Returns the result of ([string]::Equals($a, $b, [stringcomparison]::ordinal)) if $a and $b are strings.
Returns $null if $a or $b is not a string.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-String $a -Normalization FormC</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a string that is compatible with Normalization FormC.
Returns $false if $a is not a string that is compatible with Normalization FormC.

NOTE: See the -Normalization parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 5 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-String $a -eq $b -FormCompatible</dev:code>
        <dev:remarks>
          <maml:para>Returns the result of (Test-String $a -eq $b) if $a has a compatible Normalization Form with $b.
Returns $null if $a does not have a compatible Normalization with $b.

NOTE: See the -Normalization parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 6 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-String $a -eq $b -FormCompatible -Normalization FormKC, FormKD</dev:code>
        <dev:remarks>
          <maml:para>Returns the result of (Test-String $a -eq $b -FormCompatible) if $a and $b are strings that are compatible with Normalization FormKC or Normalization FormKD.
Returns $null if $a or $b is not a string that is compatible with Normalization FormKC or Normalization FormKD.

NOTE: See the -Normalization parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-DateTime</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Guid</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Number</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Text</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-TimeSpan</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Version</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-Text</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison operators when texts are being tested in unit test scenarios with operators that are sensitive to culture and language.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>Text</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function contains text operators that are sensitive to language and culture. These operators are: Match, NotMatch, Contains, NotContains, StartsWith, NotStartsWith, EndsWith, NotEndsWith, Equals, NotEquals, LessThan, GreaterThan, LessThanOrEqualTo, and GreaterThanOrEqualTo.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid operation. See each parameter for specific conditions that causes this function to return $true, $false, or $null.

The default for this function is to use case-insensitive operations using InvariantCulture. See the -CaseSensitive and -UseCurrentCulture parameters for more details.

Note about language and culture
===============================

All the operators mentioned above will be affected by the different rules of languages and cultures. From the MSDN documentation, it seems that the regular expression operators (Match and NotMatch) are the only operators listed above that cannot be used in a way that is not sensitive to language or culture.

Use Test-String if you want text operators that are not affected by language and culture.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsText</maml:name>
          <maml:description>
            <maml:para>Tests if the value is text.

Return Value   Condition
------------   ---------
$null          never
$false         value is not of type System.String
$true          value is of type System.String</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Match</maml:name>
          <maml:description>
            <maml:para>Tests if the first value matches the regular expression pattern in the second.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         Regex.IsMatch(String, String, RegexOptions) returns $false
$true          Regex.IsMatch(String, String, RegexOptions) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotMatch</maml:name>
          <maml:description>
            <maml:para>Tests if the first value does not match the regular expression pattern in the second.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         Regex.IsMatch(String, String, RegexOptions) returns $true
$true          Regex.IsMatch(String, String, RegexOptions) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Contains</maml:name>
          <maml:description>
            <maml:para>Tests if the first value contains the second.

Note: The empty string is inside all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method IndexOf(String, StringComparison) &lt; 0
$true          String method IndexOf(String, StringComparison) &gt;= 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotContains</maml:name>
          <maml:description>
            <maml:para>Tests if the first value does not contain the second.

Note: The empty string is inside all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method IndexOf(String, StringComparison) &gt;= 0
$true          String method IndexOf(String, StringComparison) &lt; 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>StartsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first value starts with the second.

Note: The empty string starts all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method StartsWith(String, StringComparison) returns $false
$true          String method StartsWith(String, StringComparison) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotStartsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first value does not start with the second.

Note: The empty string starts all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method StartsWith(String, StringComparison) returns $true
$true          String method StartsWith(String, StringComparison) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>EndsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first value ends with the second.

Note: The empty string ends all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method EndsWith(String, StringComparison) returns $false
$true          String method EndsWith(String, StringComparison) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>NotEndsWith</maml:name>
          <maml:description>
            <maml:para>Tests if the first value does not end with the second.

Note: The empty string ends all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method EndsWith(String, StringComparison) returns $true
$true          String method EndsWith(String, StringComparison) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Equals(String, String, StringComparison) returns $false
$true          String.Equals(String, String, StringComparison) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Equals(String, String, StringComparison) returns $true
$true          String.Equals(String, String, StringComparison) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &gt;= 0
$true          String.Compare(String, String, StringComparison) &lt; 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &gt; 0
$true          String.Compare(String, String, StringComparison) &lt;= 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &lt;= 0
$true          String.Compare(String, String, StringComparison) &gt; 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Text</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &lt; 0
$true          String.Compare(String, String, StringComparison) &gt;= 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>CaseSensitive</maml:name>
          <maml:description>
            <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
          </maml:description>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>UseCurrentCulture</maml:name>
          <maml:description>
            <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsText</maml:name>
        <maml:description>
          <maml:para>Tests if the value is text.

Return Value   Condition
------------   ---------
$null          never
$false         value is not of type System.String
$true          value is of type System.String</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Match</maml:name>
        <maml:description>
          <maml:para>Tests if the first value matches the regular expression pattern in the second.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         Regex.IsMatch(String, String, RegexOptions) returns $false
$true          Regex.IsMatch(String, String, RegexOptions) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotMatch</maml:name>
        <maml:description>
          <maml:para>Tests if the first value does not match the regular expression pattern in the second.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         Regex.IsMatch(String, String, RegexOptions) returns $true
$true          Regex.IsMatch(String, String, RegexOptions) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Contains</maml:name>
        <maml:description>
          <maml:para>Tests if the first value contains the second.

Note: The empty string is inside all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method IndexOf(String, StringComparison) &lt; 0
$true          String method IndexOf(String, StringComparison) &gt;= 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotContains</maml:name>
        <maml:description>
          <maml:para>Tests if the first value does not contain the second.

Note: The empty string is inside all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method IndexOf(String, StringComparison) &gt;= 0
$true          String method IndexOf(String, StringComparison) &lt; 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>StartsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first value starts with the second.

Note: The empty string starts all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method StartsWith(String, StringComparison) returns $false
$true          String method StartsWith(String, StringComparison) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotStartsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first value does not start with the second.

Note: The empty string starts all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method StartsWith(String, StringComparison) returns $true
$true          String method StartsWith(String, StringComparison) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>EndsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first value ends with the second.

Note: The empty string ends all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method EndsWith(String, StringComparison) returns $false
$true          String method EndsWith(String, StringComparison) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>NotEndsWith</maml:name>
        <maml:description>
          <maml:para>Tests if the first value does not end with the second.

Note: The empty string ends all texts.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String method EndsWith(String, StringComparison) returns $true
$true          String method EndsWith(String, StringComparison) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Equals(String, String, StringComparison) returns $false
$true          String.Equals(String, String, StringComparison) returns $true

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Equals(String, String, StringComparison) returns $true
$true          String.Equals(String, String, StringComparison) returns $false

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &gt;= 0
$true          String.Compare(String, String, StringComparison) &lt; 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &gt; 0
$true          String.Compare(String, String, StringComparison) &lt;= 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &lt;= 0
$true          String.Compare(String, String, StringComparison) &gt; 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not of type System.String
$false         String.Compare(String, String, StringComparison) &lt; 0
$true          String.Compare(String, String, StringComparison) &gt;= 0

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>CaseSensitive</maml:name>
        <maml:description>
          <maml:para>Makes the operators case-sensitive.

If this parameter is not specified, the operators will be case-insensitive.

*See the -UseCurrentCulture parameter for details about how language and culture can affect this parameter.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>UseCurrentCulture</maml:name>
        <maml:description>
          <maml:para>Makes the operators use the language rules of the current culture.

If this parameter is not specified, the operators will use the language rules from System.Globalization.CultureInfo.InvariantCulture. Operators using InvariantCulture will give the same results when the operations are run in different computers.

Note that the culture (including InvariantCulture) defines rules such as the ordering of the characters, the casing of the characters, and disturbingly, rules such as which characters can be ignored in text operations. This means that two string that are equal in one culture may not be equal in another culture. Even operations using InvariantCulture can compare two strings of different lengths as equal because the strings contain characters which are considered ignorable by the culture.

See the MSDN documentation for System.Globalization.CultureInfo for more information.</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'text?' 'test-text'

#if you have an assert function, you can write assertions like this
assert (text? $greeting)
assert (text? $greeting -match '[chj]ello world')
assert (text? $greeting -startswith 'Hello' -casesensitive -usecurrentculture)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Text $a</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is text (an object of type System.String).</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Text $a -eq $b</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b contains text that are equal according to the rules of InvariantCulture.
Returns $null if $a or $b is not text.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Text $a -eq $b -CaseSensitive -UseCurrentCulture</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b contains text that are equal (both in content and in case) according to the rules of the culture currently being used by PowerShell.
Returns $null if $a or $b is not text.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 4 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Text $a -match $b</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if the text in $a matches the regular expression pattern in $b (case-insensitive match) according to the rules of InvariantCulture.
Returns $null if $a or $b is not text.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-DateTime</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Guid</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Number</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-String</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-TimeSpan</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Version</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-TimeSpan</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison operators when testing TimeSpan objects in unit test scenarios.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>TimeSpan</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests a TimeSpan object for type and equality without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid test. See each parameter for specific conditions that causes this function to return $true, $false, or $null.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsTimeSpan</maml:name>
          <maml:description>
            <maml:para>Tests if the value is a TimeSpan value.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a TimeSpan
$true          value is a TimeSpan</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) != 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) == 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) == 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) != 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt;= 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt; 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt;= 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-TimeSpan</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt; 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsTimeSpan</maml:name>
        <maml:description>
          <maml:para>Tests if the value is a TimeSpan value.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a TimeSpan
$true          value is a TimeSpan</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) != 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) == 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) == 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) != 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt;= 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt; 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt;= 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a TimeSpan
$false         System.TimeSpan.Compare(TimeSpan, TimeSpan) &lt; 0
$true          System.TimeSpan.Compare(TimeSpan, TimeSpan) &gt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Property</maml:name>
        <maml:description>
          <maml:para>Compares the TimeSpan values using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Days, Hours, Minutes, Seconds, Milliseconds, Ticks, TotalDays, TotalHours, TotalMilliseconds, TotalMinutes, TotalSeconds

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two TimeSpan objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the hours property is compared, an expression like $a.psbase.hours is used instead of $a.hours.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        <dev:type>
          <maml:name>String[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'timespan?' 'test-timeSpan'

assert-true (timespan? $a)
assert-true (timespan? $a -eq $b -property days, hours, minutes)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-TimeSpan $a</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a TimeSpan object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-TimeSpan $a -eq $b</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both TimeSpan objects with the same value.
Returns $null if $a or $b is not a TimeSpan object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-TimeSpan $a -eq $b -property days, hours</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both TimeSpan objects with the same days and hours values.
Returns $null if $a or $b is not a TimeSpan object.

Note that the order of the properties specified is significant. See the -Property parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-DateTime</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Guid</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Number</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-String</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Text</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Version</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-True</command:name>
      <maml:description>
        <maml:para>Test that a value is the Boolean value $true.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>True</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests if a value is $true without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

    Return Value   Condition
    ------------   ---------
    $null          never
    $false         value is not of type System.Boolean
                   value is not $true
    $true          value is $true</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-True</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'true?' 'test-true'

assert-all    $items {param($a) (true? $a.b) -and (true? $a.c)}
assert-exists $items {param($a) (true? $a.d) -xor (true? $a.e)}</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-True 1</dev:code>
        <dev:remarks>
          <maml:para>Test if the number 1 is $true without performing any implicit conversions.

Note:
Compare the example above with the following expressions:
    1 -eq $true
    10 -eq $true
and see how tests can become confusing if those numbers were stored in variables.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-True @($true)</dev:code>
        <dev:remarks>
          <maml:para>Test if the array is $true without filtering semantics.

Note:
Compare the example above with the following expressions:
    @(1, $true) -eq $true
    @(-1, 0, 1, 2, 3) -eq $true
and see how tests can become confusing if the value is stored in a variable or if the value is not expected to be an array.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-False</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Null</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotTrue</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotFalse</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotNull</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-All</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Exists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-NotExists</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
  <command:command xmlns:maml="http://schemas.microsoft.com/maml/2004/10" xmlns:command="http://schemas.microsoft.com/maml/dev/command/2004/10" xmlns:dev="http://schemas.microsoft.com/maml/dev/2004/10" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
    <command:details>
      <command:name>Test-Version</command:name>
      <maml:description>
        <maml:para>An alternative to PowerShell's comparison operators when testing Version objects in unit test scenarios.</maml:para>
      </maml:description>
      <maml:copyright>
        <maml:para />
      </maml:copyright>
      <command:verb>Test</command:verb>
      <command:noun>Version</command:noun>
      <dev:version />
    </command:details>
    <maml:description>
      <maml:para>This function tests a Version object for type and equality without the implicit conversions or the filtering semantics from the PowerShell comparison operators.

This function will return one of the following values:
    $true
    $false
    $null

A return value of $null indicates an invalid test. See each parameter for specific conditions that causes this function to return $true, $false, or $null.</maml:para>
    </maml:description>
    <command:syntax>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>IsVersion</maml:name>
          <maml:description>
            <maml:para>Tests if the value is a Version object.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a Version object
$true          value is a Version object</maml:para>
          </maml:description>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
          <maml:name>Equals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) != 0
$true          System.Version method CompareTo(Version) == 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
          <maml:name>NotEquals</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) == 0
$true          System.Version method CompareTo(Version) != 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
          <maml:name>LessThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &gt;= 0
$true          System.Version method CompareTo(Version) &lt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
          <maml:name>LessThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &gt; 0
$true          System.Version method CompareTo(Version) &lt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
          <maml:name>GreaterThan</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &lt;= 0
$true          System.Version method CompareTo(Version) &gt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
      <command:syntaxItem>
        <maml:name>Test-Version</maml:name>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
          <maml:name>Value</maml:name>
          <maml:description>
            <maml:para>The value to test.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
          <maml:name>GreaterThanOrEqualTo</maml:name>
          <maml:description>
            <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &lt; 0
$true          System.Version method CompareTo(Version) &gt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        </command:parameter>
        <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
          <maml:name>Property</maml:name>
          <maml:description>
            <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
          </maml:description>
          <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        </command:parameter>
      </command:syntaxItem>
    </command:syntax>
    <command:parameters>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="1" aliases="">
        <maml:name>Value</maml:name>
        <maml:description>
          <maml:para>The value to test.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>IsVersion</maml:name>
        <maml:description>
          <maml:para>Tests if the value is a Version object.

Return Value   Condition
------------   ---------
$null          never
$false         value is not a Version object
$true          value is a Version object</maml:para>
        </maml:description>
        <command:parameterValue required="false" variableLength="false">SwitchParameter</command:parameterValue>
        <dev:type>
          <maml:name>SwitchParameter</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue>False</dev:defaultValue>
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="eq">
        <maml:name>Equals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is equal to the second.

The -Equals parameter has the alias -eq.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) != 0
$true          System.Version method CompareTo(Version) == 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ne">
        <maml:name>NotEquals</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is not equal to the second.

The -NotEquals parameter has the alias -ne.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) == 0
$true          System.Version method CompareTo(Version) != 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="lt">
        <maml:name>LessThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than the second.

The -LessThan parameter has the alias -lt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &gt;= 0
$true          System.Version method CompareTo(Version) &lt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="le">
        <maml:name>LessThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is less than or equal to the second.

The -LessThanOrEqualTo parameter has the alias -le.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &gt; 0
$true          System.Version method CompareTo(Version) &lt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="gt">
        <maml:name>GreaterThan</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than the second.

The -GreaterThan parameter has the alias -gt.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &lt;= 0
$true          System.Version method CompareTo(Version) &gt; 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="true" variableLength="false" globbing="false" pipelineInput="false" position="named" aliases="ge">
        <maml:name>GreaterThanOrEqualTo</maml:name>
        <maml:description>
          <maml:para>Tests if the first value is greater than or equal to the second.

The -GreaterThanOrEqualTo parameter has the alias -ge.

Return Value   Condition
------------   ---------
$null          one or both of the values is not a Version object
$false         System.Version method CompareTo(Version) &lt; 0
$true          System.Version method CompareTo(Version) &gt;= 0

Note: If the -Property parameter is specified, a different comparison method is used.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="false">Object</command:parameterValue>
        <dev:type>
          <maml:name>Object</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
      <command:parameter required="false" variableLength="true" globbing="false" pipelineInput="false" position="named" aliases="">
        <maml:name>Property</maml:name>
        <maml:description>
          <maml:para>Compares the Version objects using the specified properties.

Note that the order that you specify the properties is significant. The first property specified has the highest priority in the comparison, and the last property specified has the lowest priority in the comparison.

Allowed Properties
------------------
Major, Minor, Build, Revision, MajorRevision, MinorRevision

No wildcards are allowed.
No calculated properties (script blocks) are allowed.
Specifying this parameter with a $null or an empty array causes the comparisons to return $null.

Comparison method
-----------------
1. Start with the first property specified.
2. Compare the properties from the two Version objects using the CompareTo method.
3. If the properties are equal, repeat steps 2 and 3 with the remaining properties.
4. Done.

PowerShell Note:
Synthetic properties are not used in comparisons.
For example, when the build property is compared, an expression like $a.psbase.build is used instead of $a.build.</maml:para>
        </maml:description>
        <command:parameterValue required="true" variableLength="true">String[]</command:parameterValue>
        <dev:type>
          <maml:name>String[]</maml:name>
          <maml:uri />
        </dev:type>
        <dev:defaultValue />
      </command:parameter>
    </command:parameters>
    <command:inputTypes>
      <command:inputType>
        <dev:type>
          <maml:name>None

This function does not accept input from the pipeline.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:inputType>
    </command:inputTypes>
    <command:returnValues>
      <command:returnValue>
        <dev:type>
          <maml:name>System.Boolean

This function returns a Boolean if the test can be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
      <command:returnValue>
        <dev:type>
          <maml:name>$null

This function returns $null if the test cannot be performed.</maml:name>
          <maml:uri />
        </dev:type>
        <maml:description>
          <maml:para />
        </maml:description>
      </command:returnValue>
    </command:returnValues>
    <command:terminatingErrors />
    <command:nonTerminatingErrors />
    <maml:alertSet>
      <maml:alert>
        <maml:para>An example of how this function might be used in a unit test.

#recommended alias
set-alias 'version?' 'test-version'

assert-true (version? $a)
assert-true (version? $a -eq $b -property major, minor, build)</maml:para>
      </maml:alert>
    </maml:alertSet>
    <command:examples>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 1 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Version $a</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a is a Version object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 2 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Version $a -eq $b</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both Version objects with the same value.
Returns $null if $a or $b is not a Version object.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
      <command:example>
        <maml:title>-------------------------- EXAMPLE 3 --------------------------</maml:title>
        <maml:introduction>
          <maml:para>PS C:\&gt;</maml:para>
        </maml:introduction>
        <dev:code>Test-Version $a -eq $b -property major, minor</dev:code>
        <dev:remarks>
          <maml:para>Returns $true if $a and $b are both Version objects with the same major and minor values.
Returns $null if $a or $b is not a Version object.

Note that the order of the properties specified is significant. See the -Property parameter for more details.</maml:para>
          <maml:para />
          <maml:para />
          <maml:para />
          <maml:para />
        </dev:remarks>
      </command:example>
    </command:examples>
    <maml:relatedLinks>
      <maml:navigationLink>
        <maml:linkText>Test-DateTime</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Guid</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Number</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-String</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-Text</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
      <maml:navigationLink>
        <maml:linkText>Test-TimeSpan</maml:linkText>
        <maml:uri />
      </maml:navigationLink>
    </maml:relatedLinks>
  </command:command>
</helpItems>
